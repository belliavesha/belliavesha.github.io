<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Okiya-like Solver â€” 3Ã—3 / 4Ã—4 / 5Ã—5 / 6Ã—6</title>
  <style>
    :root { 
      --bg: #0f1115;
      --panel: #171923;
      --text: #e6e8ef;
      --muted: #9aa3b2;
      --accent: #7c9cf6;
      --good: #5dd39e;
      --bad: #f18f97;
      --p1: #ff6b6b;
      --p2: #6bd0ff;
      --hl: rgba(124,156,246,0.25);
      --hint: #ffd166; 
    }
    html, body {
      height: 100%;
    }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 70% -10%, #1d2130, #0f1115);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
      color: var(--text);
      display: grid;
      place-items: center;
    }
    .app {
      width: min(1200px, 96vw);
      padding: 20px;
    }
    header {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
    }
    .title {
      font-weight: 800;
      letter-spacing: .3px;
      font-size: clamp(18px, 2.2vw, 24px);
    }
    .sub {
      color: var(--muted);
      font-size: 13px;
    }
    .panel {
      background: linear-gradient(180deg, #1a1d29, #121521);
      border: 1px solid #24283a;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .4);
    }
    .board-wrap {
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 16px;
      margin-top: 16px;
    }
    .board {
      display: grid;
      gap: 10px;
      padding: 14px;
    }
    .tile {
      position: relative;
      aspect-ratio: 1/1;
      background: radial-gradient(120% 120% at 30% 20%, #2a3148, #1a2035 60%, #14192b 100%);
      border: 1px solid #2c3350;
      border-radius: 12px;
      cursor: pointer;
      transition: transform .08s ease, box-shadow .15s ease, border-color .15s ease;
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .tile:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, .35);
    }
    .tile.disabled {
      opacity: .45;
      cursor: not-allowed;
    }
    .tile.highlight {
      outline: 2px dashed var(--accent);
      box-shadow: inset 0 0 0 200vmax var(--hl);
    }
    .tile.hint {
      outline: 2px solid var(--hint);
      box-shadow: inset 0 0 0 200vmax rgba(255, 209, 102, .18);
    }
    .symbols {
      display: grid;
      grid-template-columns: 1fr;
      place-items: center;
      text-align: center;
    }
    .sym-emoji {
      font-size: clamp(22px, 2.8vw, 34px);
      line-height: 1;
      filter: drop-shadow(0 1px 0 rgba(255, 255, 255, .06));
    }
    .sym-text {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .3px;
      margin-top: 2px;
    }
    .token {
      position: absolute;
      inset: 6px;
      border-radius: 12px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08), 0 6px 18px rgba(0, 0, 0, .6);
      display: grid;
      place-items: center;
      font-weight: 800;
      letter-spacing: .5px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .6);
      color: #0a0c12;
    }
    .token.p1 {
      background: radial-gradient(120% 120% at 30% 20%, #ff8a8a, #ff6b6b 60%, #e85b5b 100%);
    }
    .token.p2 {
      background: radial-gradient(120% 120% at 30% 20%, #93e0ff, #6bd0ff 60%, #4fb9ea 100%);
    }
    .sidebar {
      min-width: 320px;
      padding: 16px;
      display: grid;
      gap: 12px;
      align-content: start;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .pill {
      padding: 8px 12px;
      border-radius: 12px;
      background: #20253a;
      border: 1px solid #313a5b;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .kv {
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }
    .kv .k {
      opacity: .8;
    }
    .btn {
      appearance: none;
      border: 0;
      border-radius: 12px;
      background: linear-gradient(180deg, #334175, #27325b);
      color: #e9edff;
      padding: 8px 12px;
      font-weight: 600;
      letter-spacing: .3px;
      cursor: pointer;
      border: 1px solid #3d4b83;
      box-shadow: 0 6px 18px rgba(0, 0, 0, .35);
      transition: transform .06s ease, filter .06s ease, box-shadow .06s ease;
    }
    .btn:hover {
      transform: translateY(-1px);
    }
    .btn.active {
      background: linear-gradient(180deg, #4a59a0, #3b4c85);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, .35), 0 6px 18px rgba(0, 0, 0, .35);
      border-color: #4a59a0;
    }
    .status {
      padding: 10px 12px;
      border-radius: 12px;
      background: #1a1f31;
      border: 1px solid #2a345a;
    }
    .winner {
      color: var(--good);
      font-weight: 800;
    }
    .tiny {
      font-size: 12px;
      color: #9aa3b2;
    }
    .tooltip {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      background: #0b0e16;
      color: #eaf0ff;
      border: 1px solid #2a3257;
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
      opacity: 0;
      transform: translate(-50%, -140%);
      transition: opacity .06s ease;
    }
    .coord-col {
      position: absolute;
      top: 4px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: #a9b3d1;
      opacity: .8;
      pointer-events: none;
    }
    .coord-row {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
      color: #a9b3d1;
      opacity: .8;
      pointer-events: none;
    }
    .seg {
      display: inline-flex;
      background: #1a1e2f;
      border: 1px solid #2a3257;
      border-radius: 12px;
      overflow: hidden;
    }
    .seg button {
      background: transparent;
      border: 0;
      color: #c9d2ff;
      padding: 8px 10px;
      cursor: pointer;
    }
    .seg button.active {
      background: #2a3353;
    }
    .controls {
      display: grid;
      gap: 8px;
    }
    .controls .row {
      gap: 8px;
    }
    select {
      background: #1a1e2f;
      color: #e9edff;
      border: 1px solid #2a3257;
      border-radius: 10px;
      padding: 6px 10px;
    }
    label {
      font-size: 12px;
      color: #9aa3b2;
    }
    input[type=text] {
      background: #1a1e2f;
      color: #e9edff;
      border: 1px solid #2a3257;
      border-radius: 10px;
      padding: 6px 10px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">Okiya-like â€” 3Ã—3 / 4Ã—4 / 5Ã—5 / 6Ã—6 with Solver</div>
        <div class="sub">Exact Î±â€“Î² engine (depth-limited), hover hints, best-move highlight. Customizable win rules.</div>
      </div>
      <div class="row">
        <div class="seg" id="sizeSeg">
          <button data-n="3" class="active">3Ã—3</button>
          <button data-n="4">4Ã—4</button>
          <button data-n="5">5Ã—5</button>
          <button data-n="6">6Ã—6</button>
        </div>
        <input type="text" id="seedInput" placeholder="Seed (optional)" style="width:120px"/>
        <button id="newGameBtn" class="btn">New Game</button>
        <button id="undoBtn" class="btn">Undo</button>
      </div>
    </header>

    <div class="board-wrap">
      <div id="board" class="board panel" aria-label="board"></div>
      <aside class="sidebar panel">
        <div class="row">
          <span class="pill kv" id="turnBadge">
            <span class="k">Current player:</span>
            <span class="v" style="display:inline-flex;align-items:center;gap:8px;">
              <span id="turnSwatch" style="width:14px;height:14px;border-radius:999px;background:var(--p1);"></span>
              <span id="turnText">Red</span>
            </span>
          </span>
        </div>
        <div class="row">
          <span class="pill kv">
            <span class="k">Last tile:</span>
            <span class="v" id="lastTile">â€”</span>
          </span>
        </div>
        <div class="status" id="statusBox">â€”</div>

        <div class="controls">
          <div class="row">
            <label for="winLenSel">Win length</label>
            <select id="winLenSel"></select>
            <button id="diagBtn" class="btn active">Diagonals</button>
            <button id="sqBtn" class="btn active">2Ã—2 Square</button>
          </div>
          <div class="row">
            <label for="depthSel">Depth</label>
            <select id="depthSel">
              <option value="3">3</option>
              <option value="5" selected>5</option>
            </select>
          </div>
          <div class="row">
            <button id="toggleHintsBtn" class="btn">Hints</button>
            <button id="bestBtn" class="btn">Best Move</button>
          </div>
        </div>

        <div id="engineBox" class="status tiny" style="margin-top:8px;">â€”</div>
        <div class="badge" style="opacity:.8;margin-top:8px;">Legend</div>
        <div class="list" id="legendBox" style="font-size:13px;color:#9aa3b2;line-height:1.2"></div>
        <div class="badge" style="opacity:.8;margin-top:8px;">Game Log</div>
        <div id="logBox" class="status tiny" style="height:160px;overflow:auto;white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">â€”</div>
      </aside>
    </div>
  </div>
  <div id="tooltip"></div>

  <template id="tileTpl">
    <div class="tile" role="button" aria-label="tile">
      <div class="symbols">
        <div class="sym-emoji"></div>
        <div class="sym-text"></div>
      </div>
    </div>
  </template>

  <script>
    // ===== Symbol pools =====
    const ALL_PLANTS = [
      { key: 'maple', emoji: 'ðŸ', label: 'Maple' },
      { key: 'cherry', emoji: 'ðŸŒ¸', label: 'Cherry' },
      { key: 'pine', emoji: 'ðŸŒ²', label: 'Pine' },
      { key: 'iris', emoji: 'ðŸŒ¿', label: 'Iris' },
      { key: 'cactus', emoji: 'ðŸŒµ', label: 'Cactus' },
      { key: 'bamboo', emoji: 'ðŸŽ‹', label: 'Bamboo' },
    ];

    const ALL_MOTIFS = [
      { key: 'sun', emoji: 'â˜€ï¸', label: 'Sun' },
      { key: 'bird', emoji: 'ðŸ¦', label: 'Bird' },
      { key: 'rain', emoji: 'ðŸŒ§ï¸', label: 'Rain' },
      { key: 'poem', emoji: 'ðŸ“', label: 'Poem' },
      { key: 'moon', emoji: 'ðŸŒ™', label: 'Moon' },
      { key: 'fan', emoji: 'ðŸª­', label: 'Fan' },
    ];

    // ===== UI handles =====
    const boardEl = document.getElementById('board');
    const tileTpl = document.getElementById('tileTpl');
    const statusBox = document.getElementById('statusBox');
    const lastTileEl = document.getElementById('lastTile');
    const turnText = document.getElementById('turnText');
    const turnSwatch = document.getElementById('turnSwatch');
    const newGameBtn = document.getElementById('newGameBtn');
    const undoBtn = document.getElementById('undoBtn');
    const toggleHintsBtn = document.getElementById('toggleHintsBtn');
    const bestBtn = document.getElementById('bestBtn');
    const engineBox = document.getElementById('engineBox');
    const tooltip = document.getElementById('tooltip');
    const sizeSeg = document.getElementById('sizeSeg');
    const legendBox = document.getElementById('legendBox');
    const logBox = document.getElementById('logBox');
    const winLenSel = document.getElementById('winLenSel');
    const diagBtn = document.getElementById('diagBtn');
    const sqBtn = document.getElementById('sqBtn');
    const depthSel = document.getElementById('depthSel');
    const seedInput = document.getElementById('seedInput');

    // ===== Global state =====
    const state = {
      n: 3,
      plants: [],
      motifs: [],
      grid: [],
      turn: 'p1',
      lastRemoved: null,
      history: [],
      winner: null,
      tt: new Map(),
      nodes: 0,
      hints: null,
      hintsOn: false,
      bestOn: false,
      rootCache: new Map(),
      winLen: 3,
      diagOn: true,
      squareOn: true,
      maxDepth: 5,
      seed: "",
      rng: Math.random,
      moveLog: [],
    };

    // ===== Helpers =====
    function modeSets(n) {
      return {
        plants: ALL_PLANTS.slice(0, n),
        motifs: ALL_MOTIFS.slice(0, n)
      };
    }

    function shuffled(a) {
      const rnd = state.rng || Math.random;
      return a.map(v => [rnd(), v])
               .sort((x, y) => x[0] - y[0])
               .map(x => x[1]);
    }

    function xfnv1a(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
      }
      return () => h >>> 0; // Ensure the hash is returned as an unsigned 32-bit integer
    }
      
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function makeRngFromSeed(seed) {
      const h = xfnv1a(String(seed))();
      return mulberry32(h);
    }

    function randomSeedString() {
      if (window.crypto && crypto.getRandomValues) {
        const a = new Uint32Array(2);
        crypto.getRandomValues(a);
        return Array.from(a)
               .map(x => x.toString(16).padStart(8, '0'))
               .join('')
               .slice(0, 8);
      }
      return Math.floor(Math.random() * 0xffffffff).toString(16).padStart(8, '0');
    }

    function genDeck() {
      const d = [];
      for (const p of state.plants) {
        for (const m of state.motifs) {
          d.push({ plant: p.key, motif: m.key });
        }
      }
      return shuffled(d);
    }

    function plantInfo(k) {
      return state.plants.find(p => p.key === k);
    }

    function motifInfo(k) {
      return state.motifs.find(m => m.key === k);
    }

    function isBorderCell(r, c) {
      const n = state.n;
      return r === 0 || c === 0 || r === n - 1 || c === n - 1;
    }

    function buildWinLenOptions() {
      winLenSel.innerHTML = '';
      for (let k = 2; k <= state.n; k++) {
        const o = document.createElement('option');
        o.value = String(k);
        o.textContent = `${k} in a row`;
        if (k === state.winLen) o.selected = true;
        winLenSel.appendChild(o);
      }
    }

    function setMode(n) {
      state.n = n;
      const s = modeSets(n);
      state.plants = s.plants;
      state.motifs = s.motifs;
      state.winLen = Math.min(n, state.winLen || n);
      rebuildLegend();
      newGame();
      buildWinLenOptions();
    }

    function rebuildLegend() {
      const plants = state.plants.map(x => `${x.emoji} ${x.label}`).join(' Â· ');
      const motifs = state.motifs.map(x => `${x.emoji} ${x.label}`).join(' Â· ');
      legendBox.innerHTML = `<strong>Plants:</strong> ${plants}<br><strong>Motifs:</strong> ${motifs}`;
    }

    function colLetter(c){ return String.fromCharCode(65+c); }
    function toNotation(r,c){ return `${colLetter(c)}${r+1}`; }
    function renderLog(){
      if(!state.moveLog.length){
        logBox.textContent='â€”';
        return;
      }
      const lines=[];
      for(let i=0;i<state.moveLog.length;i++){
        const mv=state.moveLog[i];
        const num=Math.floor(i/2)+1;
        const prefix=(i%2===0)? `${num}.` : `${num}â€¦`;
        lines.push(`${prefix} ${mv.player==='p1'?'R':'B'} ${mv.not}`);
      }
      logBox.textContent=lines.join("\n"); 
      logBox.scrollTop=logBox.scrollHeight;
    }

    // ===== Game lifecycle =====
    function newGame() {
      const n = state.n;
      boardEl.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
      
      const seedValue = (seedInput.value || "").trim();
      if (seedValue) {
      state.seed = seedValue;
      state.rng = makeRngFromSeed(seedValue);
      } else {
      const randomSeed = randomSeedString();
      state.seed = randomSeed;
      state.rng = makeRngFromSeed(randomSeed);
      seedInput.value = randomSeed;
      }
      
      state.grid = Array.from({ length: n }, () => Array.from({ length: n }, () => ({})));
      const deck = genDeck();
      let i = 0;
      for (let r = 0; r < n; r++) {
      for (let c = 0; c < n; c++) {
        state.grid[r][c] = { r, c, ...deck[i++], takenBy: null };
      }
      }
      
      resetGameState();
      renderLog();
      engineBox.textContent = 'â€”';
      toggleHintsBtn.classList.toggle('active', state.hintsOn = false);
      bestBtn.classList.toggle('active', state.bestOn = false);
      updateTurnDisplay();
      render();
    }

    function resetGameState() {
      state.turn = 'p1';
      state.lastRemoved = null;
      state.history = [];
      state.winner = null;
      state.tt.clear();
      state.nodes = 0;
      state.hints = null;
      state.rootCache.clear();
      state.moveLog = [];
    }

    function updateTurnDisplay() {
      turnText.textContent = 'Red';
      turnSwatch.style.background = 'var(--p1)';
      lastTileEl.textContent = 'â€”';
    }

    function canClick(cell) {
      if (state.winner) return false;
      if (cell.takenBy) return false;
      if (!state.lastRemoved) return isBorderCell(cell.r, cell.c);
      return cell.plant === state.lastRemoved.plant || cell.motif === state.lastRemoved.motif;
    }

    function legalMoves(lastRemoved, grid) {
      const n = state.n;
      const moves = [];
      const hasLastRemoved = !!lastRemoved;

      for (let r = 0; r < n; r++) {
      for (let c = 0; c < n; c++) {
        const cell = state.grid[r][c];
        const node = tileTpl.content.firstElementChild.cloneNode(true);
        node.dataset.r = r;
        node.dataset.c = c;

        const plant = plantInfo(cell.plant);
        const motif = motifInfo(cell.motif);
        node.querySelector('.sym-emoji').textContent = `${plant.emoji} ${motif.emoji}`;
        node.querySelector('.sym-text').textContent = `${plant.label} Â· ${motif.label}`;

        if (r === 0) {
        const colCoord = document.createElement('div');
        colCoord.className = 'coord-col';
        colCoord.textContent = colLetter(c);
        node.appendChild(colCoord);
        }
        if (c === 0) {
        const rowCoord = document.createElement('div');
        rowCoord.className = 'coord-row';
        rowCoord.textContent = String(r + 1);
        node.appendChild(rowCoord);
        }

        const clickable = canClick(cell);
        node.classList.toggle('disabled', !clickable);
        node.classList.toggle('highlight', clickable);
        if (bestSet.has(`${r},${c}`)) node.classList.add('hint');

        if (cell.takenBy) {
        const token = document.createElement('div');
        token.className = `token ${cell.takenBy}`;
        token.textContent = cell.takenBy === 'p1' ? 'RED' : 'BLUE';
        node.appendChild(token);
        node.classList.remove('highlight', 'hint');
        }

        node.addEventListener('click', () => placeToken(cell));
        node.addEventListener('mousemove', e => showTooltip(e, cell));
        node.addEventListener('mouseleave', hideTooltip);
        boardEl.appendChild(node);
      }
      }
    }

    function checkWinFor(player, grid) {
      const n = state.n;
      const k = state.winLen;

      const needK = line => {
        let run = 0;
        for (const v of line) {
          run = (v === player) ? run + 1 : 0;
          if (run >= k) return true;
        }
        return false;
      };

      // Check rows
      for (let r = 0; r < n; r++) {
        const line = [];
        for (let c = 0; c < n; c++) {
          line.push(grid[r][c].takenBy);
        }
        if (needK(line)) return true;
      }

      // Check columns
      for (let c = 0; c < n; c++) {
        const line = [];
        for (let r = 0; r < n; r++) {
          line.push(grid[r][c].takenBy);
        }
        if (needK(line)) return true;
      }

      // Check diagonals if enabled
      if (state.diagOn) {
        for (let c0 = 0; c0 < n; c0++) {
          const line = [];
          for (let r = 0, c = c0; r < n && c < n; r++, c++) {
            line.push(grid[r][c].takenBy);
          }
          if (needK(line)) return true;
        }
        for (let r0 = 1; r0 < n; r0++) {
          const line = [];
          for (let r = r0, c = 0; r < n && c < n; r++, c++) {
            line.push(grid[r][c].takenBy);
          }
          if (needK(line)) return true;
        }
        for (let c0 = n - 1; c0 >= 0; c0--) {
          const line = [];
          for (let r = 0, c = c0; r < n && c >= 0; r++, c--) {
            line.push(grid[r][c].takenBy);
          }
          if (needK(line)) return true;
        }
        for (let r0 = 1; r0 < n; r0++) {
          const line = [];
          for (let r = r0, c = n - 1; r < n && c >= 0; r++, c--) {
            line.push(grid[r][c].takenBy);
          }
          if (needK(line)) return true;
        }
      }

      // Check squares if enabled
      if (state.squareOn) {
        for (let r = 0; r < n - 1; r++) {
          for (let c = 0; c < n - 1; c++) {
            if (
              grid[r][c].takenBy === player &&
              grid[r + 1][c].takenBy === player &&
              grid[r][c + 1].takenBy === player &&
              grid[r + 1][c + 1].takenBy === player
            ) {
              return true;
            }
          }
        }
      }

      return false;
    }

    function cloneGrid(g) {
      return g.map(row => row.map(cell => ({ ...cell })));
    }

    // ===== Solver (Î±â€“Î²) =====
    const INF = 1_000_000;

    function posKey(turn, lastRemoved, grid) {
      const n = state.n;
      let bits = "";
      for (let r = 0; r < n; r++) {
        for (let c = 0; c < n; c++) {
          bits += grid[r][c].takenBy ? (grid[r][c].takenBy === 'p1' ? '1' : '2') : '.';
        }
      }

      let layout = "";
      for (let r = 0; r < n; r++) {
        for (let c = 0; c < n; c++) {
          const cell = grid[r][c];
          const pi = state.plants.findIndex(p => p.key === cell.plant);
          const mi = state.motifs.findIndex(m => m.key === cell.motif);
          layout += `${pi}/${mi},`;
        }
      }

      const lr = lastRemoved ? `${lastRemoved.plant}|${lastRemoved.motif}` : 'NONE';
      return `${state.n}|${turn}|${lr}|L:${layout}|B:${bits}|${state.winLen}|${state.diagOn ? 'D' : '-'}|${state.squareOn ? 'S' : '-'}|d${state.maxDepth}`;
    }


    function placeToken(cell){
      if(!canClick(cell)) return;
      state.history.push({r:cell.r,c:cell.c,prevLast:state.lastRemoved?{...state.lastRemoved}:null,prevTurn:state.turn,prevWinner:state.winner, notation: toNotation(cell.r,cell.c), player: state.turn});
      state.lastRemoved={plant:cell.plant,motif:cell.motif};
      cell.takenBy=state.turn;
      // log move
      state.moveLog.push({player:state.turn,r:cell.r,c:cell.c,not:toNotation(cell.r,cell.c)});
      renderLog();
      if(checkWinFor(state.turn,state.grid)){ state.winner=state.turn; state.hints=null; engineBox.textContent='â€”'; render(); return; }
      state.turn=state.turn==='p1'?'p2':'p1';
      const lm=legalMoves(state.lastRemoved,state.grid); if(lm.length===0){ state.winner=state.turn==='p1'?'p2':'p1'; }
      if(state.hintsOn||state.bestOn){ state.hints=evaluateAllMoves(); const verdict=state.hints?scoreToText(state.hints.bestScore):'â€”'; engineBox.textContent=state.hints?`${state.turn==='p1'?'Red':'Blue'} to move Â· ${verdict}. Nodes: ${state.hints.nodes.toLocaleString()} (depth ${state.maxDepth})`:'â€”'; } else { state.hints=null; engineBox.textContent='â€”'; }
      render();
    }



    function undo() {
      const step = state.history.pop();
      if (!step) return;

      state.moveLog.pop();
      renderLog();

      const cell = state.grid[step.r][step.c];
      cell.takenBy = null;
      state.lastRemoved = step.prevLast;
      state.turn = step.prevTurn;
      state.winner = step.prevWinner || null;

      if (state.hintsOn || state.bestOn) {
        state.hints = evaluateAllMoves();
        const verdict = state.hints ? scoreToText(state.hints.bestScore) : 'â€”';
        engineBox.textContent = state.hints
          ? `${state.turn === 'p1' ? 'Red' : 'Blue'} to move Â· ${verdict}. Nodes: ${state.hints.nodes.toLocaleString()} (depth ${state.maxDepth})`
          : 'â€”';
      } else {
        state.hints = null;
        engineBox.textContent = 'â€”';
      }
      
      render();
    }

    function computeHints() {
      if (state.winner) {
        engineBox.textContent = 'Game over';
        return;
      }

      state.hints = evaluateAllMoves();
      if (!state.hints) {
        engineBox.textContent = 'No moves';
        return;
      }

      const anyWin = state.hints.results.some(r => r.exact && r.score > 0);
      const allExact = state.hints.results.every(r => r.exact);
      const allLoss = allExact && state.hints.results.every(r => r.score < 0);
      
      const verdict = anyWin
        ? scoreToText(state.hints.bestScore)
        : allLoss
          ? 'Certain Loss'
          : `Unknown (depth ${state.maxDepth})`;

      engineBox.textContent = `${state.turn === 'p1' ? 'Red' : 'Blue'} to move Â· ${verdict}. Nodes: ${state.hints.nodes.toLocaleString()} (depth ${state.maxDepth})`;
    }

    function toggleHints() {
      state.hintsOn = !state.hintsOn;
      if (state.hintsOn && !state.hints) computeHints();
      toggleHintsBtn.classList.toggle('active', state.hintsOn);
      render();
    }

    function toggleBest() {
      state.bestOn = !state.bestOn;
      if (state.bestOn && !state.hints) computeHints();
      bestBtn.classList.toggle('active', state.bestOn);
      render();
    }

    function moveInfo(cell) {
      if (!canClick(cell)) return null;

      if (!state.hints) {
        if (state.hintsOn || state.bestOn) state.hints = evaluateAllMoves();
      }

      if (!state.hints) return null;

      for (const r of state.hints.results) {
        if (r.mv.r === cell.r && r.mv.c === cell.c) return r;
      }
      
      return null;
    }

    function showTooltip(e, cell) {
      if (!state.hintsOn) return hideTooltip();

      const info = moveInfo(cell);
      if (!info) {
        hideTooltip();
        return;
      }

      const text = info.exact ? scoreToText(info.score) : `Unknown (depth ${state.maxDepth})`;
      tooltip.textContent = text;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top = e.clientY + 'px';
      tooltip.style.opacity = '1';
    }

    function hideTooltip() {
      tooltip.style.opacity = '0';
    }

    // ===== Tests =====
    function runSelfTests(){
      try{
        const s=modeSets(3); state.plants=s.plants; state.motifs=s.motifs; state.n=3; state.winLen=3; newGame();
        console.assert(legalMoves(null,state.grid).length===8, 'First move must be border on 3Ã—3 (8 moves)');
        const key1=posKey('p1',null,state.grid); const key2=posKey('p1',null,cloneGrid(state.grid)); console.assert(key1===key2,'posKey stable across clones');
        state.maxDepth=3; const pack=evaluateAllMoves(); console.assert(pack && Array.isArray(pack.results),'evaluateAllMoves returns results');
        console.log('Self-tests passed.');
      }catch(e){ console.error('Self-tests failed:',e); }
    }

    // Existing test (do not change): Blue move that allows Red mate-in-1 must be scored Loss in 2
    function runExtraTests() {
      try {
        const s2 = modeSets(3);
        state.plants = s2.plants;
        state.motifs = s2.motifs;
        state.n = 3;
        state.winLen = 3;
        state.diagOn = true;
        state.squareOn = false;
        state.maxDepth = 3;
        newGame();

        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const cell = state.grid[r][c];
            cell.takenBy = null;
            cell.plant = state.plants[(r + c) % 3].key;
            cell.motif = state.motifs[0].key;
          }
        }

        state.grid[0][0].takenBy = 'p1';
        state.grid[0][1].takenBy = 'p1';
        state.turn = 'p2';
        state.lastRemoved = null;
        state.history = [];
        state.winner = null;
        state.tt.clear();
        state.rootCache.clear();

        const pack = evaluateAllMoves();
        const mvLoss = pack.results.find(r => r.mv.r === 2 && r.mv.c === 2);
        console.assert(mvLoss && mvLoss.exact && (INF + mvLoss.score) === 2, 
                       'Blue (2,2) should be Loss in 2 when it gives Red mate in 1');
        console.log('Extra tests passed.');
      } catch (e) {
        console.error('Extra tests failed:', e);
      }
    }

    function runMoreTests() {
      try {
        setMode(5);
        state.winLen = 5;
        state.maxDepth = 3;
        newGame();

        const pack = evaluateAllMoves();
        console.assert(pack.results.some(r => !r.exact) || pack.results.length > 0, 
                       'Depth-limited search should often yield some Unknown on 5Ã—5 at depth 3');

        setMode(4);
        state.winLen = 4;
        newGame();
        state.grid[0][0].takenBy = 'p1';
        state.grid[0][1].takenBy = 'p1';
        state.grid[0][2].takenBy = 'p1';
        state.turn = 'p1';
        state.lastRemoved = { plant: state.grid[0][3].plant, motif: state.grid[0][3].motif };

        const pack2 = evaluateAllMoves();
        const winMove = pack2.results.find(r => r.score === INF - 1 && r.exact);
        console.assert(!!winMove, 'Detect Win in 1 when available');

        // New tests for notation + log
        setMode(3);
        newGame();
        const cell00 = state.grid[0][0];
        state.lastRemoved = null;

        if (canClick(cell00)) {
          state.turn = 'p1';
          cell00.takenBy = null;
          placeToken(cell00);
        }

        console.assert(state.moveLog.length === 1 && state.moveLog[0].not === 'A1', 
                       'Notation should map (0,0) -> A1 and log length 1');
        undo();
        console.assert(state.moveLog.length === 0, 'Undo should pop moveLog');
        console.log('More tests passed.');
      } catch (e) {
        console.error('More tests failed:', e);
      }
    }

    (function boot() {
      const start = modeSets(3);
      state.plants = start.plants;
      state.motifs = start.motifs;
      state.winLen = 4;
      rebuildLegend();
      buildWinLenOptions();
      seedInput.value = "";
      newGame();
      // runSelfTests(); runExtraTests(); runMoreTests(); 
    })();


  </script>
</body>
</html>
